// backPropagation.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>
#include <stdlib.h>
#include <cstdlib>
#ifdef __APPLE__
#include <OpenGL/OpenGL.h>
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#endif
#include "color.h"
#include "Molecular.h"
#include <time.h>
#include <chrono>

using namespace std; 
/***********************************global variables******************************************/
int degree = 0; //0......6//
const int tempLength = 6;
const int moleNum = 50;
Color tempColors[tempLength];
Molecular moleculars[moleNum];
float velocity = .02; 
float acc = -9.8;



/********************************prototypes************************************************/

void molecularInit();
void drawFilledCircle(GLfloat x, GLfloat y, GLfloat z, GLfloat radius);
void resetColor();
void drawMoles();
void colorsInit();
void drawQuad();
void termometer();
void processSpecialKeys(int key, int mx, int my);
void drawScene();
void handleKeypress(unsigned char key, int x, int y);
void initRendering();
void handleResize(int w, int h);


void move() {
	double previousTime = glutGet(GLUT_ELAPSED_TIME);
	double newTime;
	double dt;
	double dtx,dty,dtz,posX=0,posY=0,posZ=0;
	int cnt = 100;
	while (cnt--) {
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glClearColor(1.0f, 1.0f, 204.0 / 255, 1.0f);
		glMatrixMode(GL_MODELVIEW); //Switch to the drawing perspective
		glLoadIdentity();
		/*newTime = glutGet(GLUT_ELAPSED_TIME);
		dt = newTime - previousTime;
		previousTime = newTime;*/
		dtx = (rand() % 10) / -10.0;
		dty = (rand() % 8) / -10.0;
		dtz = -1 * (2 + rand() % 3);
		posX += dtx * velocity;
		posY += dty * velocity;
		posZ += dtz * velocity;
		cout << posX<<"\t"<<posY<<"\t"<<posZ << endl;
		glTranslatef(posX/10.0,posY/10.0,0);
		glColor3f(0, 0, 0);
		drawMoles();
	}



}

/************************************************************/
int main(int argc, char** argv) {
	
	//Initialize GLUT
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(400, 400);
	//Create the window
	glutCreateWindow("Back Propagation");
	initRendering();

	molecularInit();
	colorsInit();
	//Set handler functions
	glutDisplayFunc(drawScene);
	glutKeyboardFunc(handleKeypress);
	glutReshapeFunc(handleResize);
	glutSpecialFunc(processSpecialKeys);
	
	//glutTimerFunc(25, update, 0); //Add a timer

	glutMainLoop();
	return 0;
}


/********************************************Defination*****************************************/
void molecularInit() {

	for (int i = 0; i < moleNum; i++)
	{
		moleculars[i].Randomize();
		cout << i << "\t" << moleculars[i].posX << "\t" << moleculars[i].posY << "\t" << moleculars[i].posZ << endl;
	}

}

void drawFilledCircle(GLfloat x, GLfloat y, GLfloat z, GLfloat radius) {
	int i;
	int triangleAmount = 70; //# of triangles used to draw circle

							 //GLfloat radius = 0.8f; //radius
	GLfloat twicePi = 2.0f * 3.14;

	glBegin(GL_TRIANGLE_FAN);
	glVertex3f(x, y, z); // center of circle
	for (i = 0; i <= triangleAmount; i++) {
		glVertex3f(
			x + (radius * cos(i *  twicePi / triangleAmount)),
			y + (radius * sin(i * twicePi / triangleAmount))
			, z);
	}
	glEnd();
}

void resetColor() {
	glColor3f(1, 1, 1);
}

void drawMoles() {
	resetColor();
	glPushMatrix();
	glTranslatef(0, -0.5, 0);
	glColor3f(0, 0, 0);
	for (int i = 0; i < moleNum; i++) {
		drawFilledCircle(moleculars[i].posX, moleculars[i].posY, moleculars[i].posZ, 0.05);
	}
	glPopMatrix();
}

void colorsInit() {

	tempColors[0].setColors(103.0 / 255, 119.0 / 255, 224.0 / 255);
	tempColors[1].setColors(102.0 / 255, 153.0 / 255, 225.0 / 255);
	tempColors[2].setColors(1, 1, 1);
	tempColors[3].setColors(255.0 / 255, 255.0 / 255, 153.0 / 255);
	tempColors[4].setColors(255.0 / 255, 153.0 / 255, 51.0 / 255);
	tempColors[5].setColors(225.0 / 255, 102.0 / 255, 0.0 / 255);
}

void handleKeypress(unsigned char key, int x, int y) {
	switch (key) {
	case 27: //Escape key
		exit(0);
	}
}

//Initializes 3D rendering
void initRendering() {
	glEnable(GL_DEPTH_TEST);
}

//Called when the window is resized
void handleResize(int w, int h) {
	glViewport(0, 0, w, h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(45.0, (double)w / (double)h, 1.0, 200.0);
}

void drawQuad() {

	glBegin(GL_QUADS);
	glColor3f(0.6, 0, 0.2);
	glVertex3f(-2, -1, -5.);
	glVertex3f(-1.5, 0., -5.);
	glVertex3f(1.5, 0., -5.);
	glVertex3f(0.5, -1., -5.);

	glEnd();
}

void termometer() {

	glPushMatrix();
	glTranslatef(-.5, -1, 0.);
	glBegin(GL_QUADS);
	glColor3f(tempColors[degree].red, tempColors[degree].green, tempColors[degree].blue);
	glVertex3f(2.5, 0.2, -5.);
	glVertex3f(2.7, 0.2, -5.);
	glVertex3f(2.7, 1.5, -5.);
	glVertex3f(2.5, 1.5, -5.);
	glEnd();
	drawFilledCircle(2.6, .1, -5., .15);
	glPopMatrix();


}

void processSpecialKeys(int key, int mx, int my) {

	switch (key) {

	case GLUT_KEY_UP: //increase temp
		(degree < tempLength) ? degree = tempLength - 1 : degree += 1;
		cout << degree << endl;
		glutPostRedisplay();
		break;
	case GLUT_KEY_DOWN: //decrease temp
		(degree == 0) ? degree = 0 : degree -= 1;
		cout << degree << endl;
		glutPostRedisplay();
		break;

	default:
		break;
	}


}
//Draws the 3D scene
void drawScene() {

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glClearColor(1.0f, 1.0f, 204.0 / 255, 1.0f);
	glMatrixMode(GL_MODELVIEW); //Switch to the drawing perspective
	glLoadIdentity(); //Reset the drawing perspective

	//termometer();
	//resetColor();
	move();
	
	
	//drawMoles();
	//drawQuad();
	glutSwapBuffers();
}

